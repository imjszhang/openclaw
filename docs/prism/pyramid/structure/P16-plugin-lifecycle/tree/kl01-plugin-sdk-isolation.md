# KL32: 插件开发必须实施 SDK 隔离与清单驱动，从源头界定扩展边界与依赖范围

> 所属视角：P16-plugin-lifecycle
> 上层论点：插件开发生命周期必须严格遵循"SDK 隔离 + 清单驱动 + 安全加载”规范，通过 jiti 动态加载配合严格的路径/所有权检查，构建运行时安全防线。

## 支撑论点

### 32.1: 架构设计强制实施 SDK 隔离，严禁插件直接依赖内部模块以确保编译时稳定与运行时解耦

- 逻辑顺序：结构
- 引用 atoms: PC-03, PC-04
- 引用 groups: G32

系统采用双层架构，将编译时稳定的 Plugin SDK 与运行时注入的 Plugin Runtime 分离，开发者仅能导入 `openclaw/plugin-sdk`，所有运行时能力必须通过 `api.runtime` 获取，从而杜绝了对 `src` 内部模块的非法耦合。

### 32.2: 扩展能力通过标准化清单文件显式声明，利用 JSON Schema 校验与唯一 ID 机制确立配置契约

- 逻辑顺序：结构
- 引用 atoms: PC-09, PC-10, PC-25
- 引用 groups: G32

插件创建必须包含 `openclaw.plugin.json` 清单及入口文件，其中 `id` 字段作为全局唯一标识符，配合 `configSchema` 在加载阶段强制执行配置校验，任何不匹配 Schema 的配置都将直接阻断加载流程。

### 32.3: 运行时加载采用 jiti 动态执行配合多重安全门禁，通过路径所有权检查与启用策略过滤构建防御纵深

- 逻辑顺序：时间
- 引用 atoms: PC-02, PC-07, PC-30, PC-27
- 引用 groups: G32

加载流程始于清单验证与 ID 冲突检查，随后利用 jiti 直接加载 TypeScript 文件而无需预编译，但在执行前会严格拒绝世界可写路径并验证文件所有者，最终依据全局开关与黑白名单判定是否激活。

## 论点间关系

上述论点按插件生命周期的逻辑结构展开：首先确立**架构隔离**原则以界定代码边界，其次通过**清单驱动**定义静态配置契约，最后在执行阶段落实**安全加载**的动态防御机制，三者共同构成完整的生命周期规范。

---
